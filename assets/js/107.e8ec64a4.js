(window.webpackJsonp=window.webpackJsonp||[]).push([[107],{513:function(t,o,s){"use strict";s.r(o);var a=s(46),e=Object(a.a)({},(function(){var t=this,o=t.$createElement,s=t._self._c||o;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"关于vue的疑问"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#关于vue的疑问"}},[t._v("#")]),t._v(" 关于Vue的疑问")]),t._v(" "),s("h2",{attrs:{id:"为什么patch时将当前需要处理的节点插入到旧树中未处理的节点之前"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#为什么patch时将当前需要处理的节点插入到旧树中未处理的节点之前"}},[t._v("#")]),t._v(" 为什么patch时将当前需要处理的节点插入到旧树中未处理的节点之前")]),t._v(" "),s("p",[t._v("该问题来自《深入浅出VueJS》，并且在此书patch章节中的更新策略给出了解答。")]),t._v(" "),s("p",[t._v("如果将当前需要处理的节点插入到旧树中已处理的节点之后，可能造成位置错乱。假设当前需要处理的节点A在旧树中不存在时，将其插入到旧树已处理节点之后，那么处理下一个节点B时，如果B仍然不存在于旧树中，那么此时的节点B插入到旧树已处理节点之后就造成B在A之前的错乱。")]),t._v(" "),s("h2",{attrs:{id:"vue-composition-api和slot复用对比"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#vue-composition-api和slot复用对比"}},[t._v("#")]),t._v(" Vue Composition API和Slot复用对比")]),t._v(" "),s("p",[s("a",{attrs:{href:"https://logaretm.com/blog/the-case-for-hoc-vs-composition-api/",target:"_blank",rel:"noopener noreferrer"}},[t._v("推荐阅读"),s("OutboundLink")],1)]),t._v(" "),s("p",[t._v("结论：")]),t._v(" "),s("ul",[s("li",[t._v("如果不需要扩展slot中的props，就使用slot进行复用，composition api对与prop扩展可以利用js的灵活性")]),t._v(" "),s("li",[t._v("如果在同一组件中会对相同功能使用多次，就使用slot，因为每个slot的作用域都是独立的，无需为变量重命名，而composition api需要对变量进行重命名，可能带来繁琐")])])])}),[],!1,null,null,null);o.default=e.exports}}]);